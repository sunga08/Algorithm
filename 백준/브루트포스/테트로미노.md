## 방법1
### 브루트 포스
가능한 테트로미노를 모두 미리 만들어 놓고 각 칸에서 갈 수 있는 확인하는 방법
- 하나의 테트로미노를 모든 칸에 놓아보는 방법 수 = O(NM) X 19 = 500x500x19 👉 모든 경우의 수를 확인해봐도 가능

```c++
#include <iostream>
#include <vector>

using namespace std;
int board[501][501];

int t[19][3][2] = {
    {{0,1},{0,2},{0,3}}, //ㅡ
    {{1,0},{2,0},{3,0}},
    {{0,1},{1,1},{1,0}}, //ㅁ
    {{1,0},{1,1},{2,0}}, //ㅏ
    {{1,-1},{1,0},{1,1}},
    {{1,0},{1,-1},{2,0}},
    {{0,1},{1,1},{0,2}},
    {{1,0},{2,0},{2,1}}, //ㄴ
    {{0,1},{0,2},{-1,2}},
    {{0,1},{1,1},{2,1}},
    {{1,0},{0,1},{0,2}},
    {{1,0},{2,0},{2,-1}},
    {{1,0},{1,1},{1,2}},
    {{0,1},{1,0},{2,0}},
    {{0,1},{0,2},{1,2}},
    {{1,0},{1,1},{2,1}},//ㄴㄱ
    {{0,1},{-1,1},{-1,2}},
    {{1,0},{1,-1},{2,-1}},
    {{0,1},{1,1},{1,2}}
};

int main()
{
    int n, m;
    cin >> n >> m;    
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            int tmp;
            cin >> tmp;
            board[i][j] = tmp;
        }
    }

    int maxSum = 0;
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            //각각의 칸을 시작점으로 테트로미노가 놓일 수 있는지 확인
            for (int k = 0; k < 19; k++) {
                int sum = board[i][j];
                int possible = true;
                for (int l = 0; l < 3; l++) { //하나의 테트로미노
                    int nx = i + t[k][l][0];
                    int ny = j + t[k][l][1];
                    if (nx >= 0 && nx < n && ny >= 0 && ny < m) {
                        sum += board[nx][ny]; //갈 수 있으면 칸의 숫자 더하기
                    }
                    else { //갈 수 없으면 빠져나오기
                        possible = false;
                        break;
                    }
                }

                if (possible && sum > maxSum) { //최댓값 구하기
                    maxSum = sum;                 
                }
            }
        }
    }

    cout << maxSum;

    return 0;
}
```

## 방법2
### DFS 이용

참고: https://lollolzkk.tistory.com/7
